#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
    from thrift.protocol import fastbinary
except:
    fastbinary = None


class AnnotationTemplate:
    TextClassification = 1
    TextEntity = 2
    ImageClassification = 3
    ImageDetection = 4
    ImageSegmentation = 5
    VideoClassification = 6
    TabularPrediction = 101
    TimeSeriesPrediction = 102

    _VALUES_TO_NAMES = {
        1: "TextClassification",
        2: "TextEntity",
        3: "ImageClassification",
        4: "ImageDetection",
        5: "ImageSegmentation",
        6: "VideoClassification",
        101: "TabularPrediction",
        102: "TimeSeriesPrediction",
    }

    _NAMES_TO_VALUES = {
        "TextClassification": 1,
        "TextEntity": 2,
        "ImageClassification": 3,
        "ImageDetection": 4,
        "ImageSegmentation": 5,
        "VideoClassification": 6,
        "TabularPrediction": 101,
        "TimeSeriesPrediction": 102,
    }


class AnnotationDataType:
    SingleSelector = 1
    MultipleSelector = 2
    BlankFilling = 3

    _VALUES_TO_NAMES = {
        1: "SingleSelector",
        2: "MultipleSelector",
        3: "BlankFilling",
    }

    _NAMES_TO_VALUES = {
        "SingleSelector": 1,
        "MultipleSelector": 2,
        "BlankFilling": 3,
    }


class AnnotationStatus:
    Init = 1
    Marked = 2
    Invalid = 3

    _VALUES_TO_NAMES = {
        1: "Init",
        2: "Marked",
        3: "Invalid",
    }

    _NAMES_TO_VALUES = {
        "Init": 1,
        "Marked": 2,
        "Invalid": 3,
    }


class Data:
    """
  Attributes:
   - ImageURL
   - VideoURL
   - TextURL
   - FilePath
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRING,
            'ImageURL',
            None,
            None,
        ),  # 1
        (
            2,
            TType.STRING,
            'VideoURL',
            None,
            None,
        ),  # 2
        (
            3,
            TType.STRING,
            'TextURL',
            None,
            None,
        ),  # 3
        (
            4,
            TType.STRING,
            'FilePath',
            None,
            None,
        ),  # 4
    )

    def __init__(
        self,
        ImageURL=None,
        VideoURL=None,
        TextURL=None,
        FilePath=None,
    ):
        self.ImageURL = ImageURL
        self.VideoURL = VideoURL
        self.TextURL = TextURL
        self.FilePath = FilePath

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(
                iprot.trans, TTransport.CReadableTransport
        ) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans,
                                     (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ImageURL = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.VideoURL = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.TextURL = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.FilePath = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(
                fastbinary.encode_binary(self,
                                         (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('Data')
        if self.ImageURL is not None:
            oprot.writeFieldBegin('ImageURL', TType.STRING, 1)
            oprot.writeString(self.ImageURL)
            oprot.writeFieldEnd()
        if self.VideoURL is not None:
            oprot.writeFieldBegin('VideoURL', TType.STRING, 2)
            oprot.writeString(self.VideoURL)
            oprot.writeFieldEnd()
        if self.TextURL is not None:
            oprot.writeFieldBegin('TextURL', TType.STRING, 3)
            oprot.writeString(self.TextURL)
            oprot.writeFieldEnd()
        if self.FilePath is not None:
            oprot.writeFieldBegin('FilePath', TType.STRING, 4)
            oprot.writeString(self.FilePath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.ImageURL)
        value = (value * 31) ^ hash(self.VideoURL)
        value = (value * 31) ^ hash(self.TextURL)
        value = (value * 31) ^ hash(self.FilePath)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value) for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other,
                          self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TextSelector:
    """
  Attributes:
   - Pos
   - Len
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.I32,
            'Pos',
            None,
            None,
        ),  # 1
        (
            2,
            TType.I32,
            'Len',
            None,
            None,
        ),  # 2
    )

    def __init__(
        self,
        Pos=None,
        Len=None,
    ):
        self.Pos = Pos
        self.Len = Len

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(
                iprot.trans, TTransport.CReadableTransport
        ) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans,
                                     (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.Pos = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.Len = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(
                fastbinary.encode_binary(self,
                                         (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TextSelector')
        if self.Pos is not None:
            oprot.writeFieldBegin('Pos', TType.I32, 1)
            oprot.writeI32(self.Pos)
            oprot.writeFieldEnd()
        if self.Len is not None:
            oprot.writeFieldBegin('Len', TType.I32, 2)
            oprot.writeI32(self.Len)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.Pos is None:
            raise TProtocol.TProtocolException(
                message='Required field Pos is unset!')
        if self.Len is None:
            raise TProtocol.TProtocolException(
                message='Required field Len is unset!')
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.Pos)
        value = (value * 31) ^ hash(self.Len)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value) for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other,
                          self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AnnotationData:
    """
  Attributes:
   - Type
   - Options
   - Label
   - Labels
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.I32,
            'Type',
            None,
            None,
        ),  # 1
        (
            2,
            TType.LIST,
            'Options',
            (TType.STRING, None),
            None,
        ),  # 2
        (
            3,
            TType.STRING,
            'Label',
            None,
            None,
        ),  # 3
        (
            4,
            TType.LIST,
            'Labels',
            (TType.STRING, None),
            None,
        ),  # 4
    )

    def __init__(
        self,
        Type=None,
        Options=None,
        Label=None,
        Labels=None,
    ):
        self.Type = Type
        self.Options = Options
        self.Label = Label
        self.Labels = Labels

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(
                iprot.trans, TTransport.CReadableTransport
        ) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans,
                                     (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.Type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.Options = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in xrange(_size0):
                        _elem5 = iprot.readString()
                        self.Options.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.Label = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.Labels = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in xrange(_size6):
                        _elem11 = iprot.readString()
                        self.Labels.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(
                fastbinary.encode_binary(self,
                                         (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('AnnotationData')
        if self.Type is not None:
            oprot.writeFieldBegin('Type', TType.I32, 1)
            oprot.writeI32(self.Type)
            oprot.writeFieldEnd()
        if self.Options is not None:
            oprot.writeFieldBegin('Options', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.Options))
            for iter12 in self.Options:
                oprot.writeString(iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.Label is not None:
            oprot.writeFieldBegin('Label', TType.STRING, 3)
            oprot.writeString(self.Label)
            oprot.writeFieldEnd()
        if self.Labels is not None:
            oprot.writeFieldBegin('Labels', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.Labels))
            for iter13 in self.Labels:
                oprot.writeString(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.Type is None:
            raise TProtocol.TProtocolException(
                message='Required field Type is unset!')
        if self.Options is None:
            raise TProtocol.TProtocolException(
                message='Required field Options is unset!')
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.Type)
        value = (value * 31) ^ hash(self.Options)
        value = (value * 31) ^ hash(self.Label)
        value = (value * 31) ^ hash(self.Labels)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value) for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other,
                          self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AnnotationResult:
    """
  Attributes:
   - Bbox
   - Segmentation
   - Text
   - Data
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.LIST,
            'Bbox',
            (TType.DOUBLE, None),
            None,
        ),  # 1
        (
            2,
            TType.LIST,
            'Segmentation',
            (TType.LIST, (TType.DOUBLE, None)),
            None,
        ),  # 2
        (
            3,
            TType.STRUCT,
            'Text',
            (TextSelector, TextSelector.thrift_spec),
            None,
        ),  # 3
        (
            4,
            TType.LIST,
            'Data',
            (TType.STRUCT, (AnnotationData, AnnotationData.thrift_spec)),
            None,
        ),  # 4
    )

    def __init__(
        self,
        Bbox=None,
        Segmentation=None,
        Text=None,
        Data=None,
    ):
        self.Bbox = Bbox
        self.Segmentation = Segmentation
        self.Text = Text
        self.Data = Data

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(
                iprot.trans, TTransport.CReadableTransport
        ) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans,
                                     (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.Bbox = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in xrange(_size14):
                        _elem19 = iprot.readDouble()
                        self.Bbox.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.Segmentation = []
                    (_etype23, _size20) = iprot.readListBegin()
                    for _i24 in xrange(_size20):
                        _elem25 = []
                        (_etype29, _size26) = iprot.readListBegin()
                        for _i30 in xrange(_size26):
                            _elem31 = iprot.readDouble()
                            _elem25.append(_elem31)
                        iprot.readListEnd()
                        self.Segmentation.append(_elem25)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.Text = TextSelector()
                    self.Text.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.Data = []
                    (_etype35, _size32) = iprot.readListBegin()
                    for _i36 in xrange(_size32):
                        _elem37 = AnnotationData()
                        _elem37.read(iprot)
                        self.Data.append(_elem37)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(
                fastbinary.encode_binary(self,
                                         (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('AnnotationResult')
        if self.Bbox is not None:
            oprot.writeFieldBegin('Bbox', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.Bbox))
            for iter38 in self.Bbox:
                oprot.writeDouble(iter38)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.Segmentation is not None:
            oprot.writeFieldBegin('Segmentation', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.Segmentation))
            for iter39 in self.Segmentation:
                oprot.writeListBegin(TType.DOUBLE, len(iter39))
                for iter40 in iter39:
                    oprot.writeDouble(iter40)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.Text is not None:
            oprot.writeFieldBegin('Text', TType.STRUCT, 3)
            self.Text.write(oprot)
            oprot.writeFieldEnd()
        if self.Data is not None:
            oprot.writeFieldBegin('Data', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.Data))
            for iter41 in self.Data:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.Data is None:
            raise TProtocol.TProtocolException(
                message='Required field Data is unset!')
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.Bbox)
        value = (value * 31) ^ hash(self.Segmentation)
        value = (value * 31) ^ hash(self.Text)
        value = (value * 31) ^ hash(self.Data)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value) for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other,
                          self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Annotation:
    """
  Attributes:
   - Type
   - ItemID
   - Result
   - Status
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.I32,
            'Type',
            None,
            None,
        ),  # 1
        (
            2,
            TType.STRING,
            'ItemID',
            None,
            None,
        ),  # 2
        (
            3,
            TType.LIST,
            'Result',
            (TType.STRUCT, (AnnotationResult, AnnotationResult.thrift_spec)),
            None,
        ),  # 3
        (
            4,
            TType.I32,
            'Status',
            None,
            None,
        ),  # 4
    )

    def __init__(
        self,
        Type=None,
        ItemID=None,
        Result=None,
        Status=None,
    ):
        self.Type = Type
        self.ItemID = ItemID
        self.Result = Result
        self.Status = Status

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(
                iprot.trans, TTransport.CReadableTransport
        ) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans,
                                     (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.Type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ItemID = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.Result = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in xrange(_size42):
                        _elem47 = AnnotationResult()
                        _elem47.read(iprot)
                        self.Result.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.Status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(
                fastbinary.encode_binary(self,
                                         (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('Annotation')
        if self.Type is not None:
            oprot.writeFieldBegin('Type', TType.I32, 1)
            oprot.writeI32(self.Type)
            oprot.writeFieldEnd()
        if self.ItemID is not None:
            oprot.writeFieldBegin('ItemID', TType.STRING, 2)
            oprot.writeString(self.ItemID)
            oprot.writeFieldEnd()
        if self.Result is not None:
            oprot.writeFieldBegin('Result', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.Result))
            for iter48 in self.Result:
                iter48.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.Status is not None:
            oprot.writeFieldBegin('Status', TType.I32, 4)
            oprot.writeI32(self.Status)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.Type is None:
            raise TProtocol.TProtocolException(
                message='Required field Type is unset!')
        if self.ItemID is None:
            raise TProtocol.TProtocolException(
                message='Required field ItemID is unset!')
        if self.Result is None:
            raise TProtocol.TProtocolException(
                message='Required field Result is unset!')
        if self.Status is None:
            raise TProtocol.TProtocolException(
                message='Required field Status is unset!')
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.Type)
        value = (value * 31) ^ hash(self.ItemID)
        value = (value * 31) ^ hash(self.Result)
        value = (value * 31) ^ hash(self.Status)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value) for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other,
                          self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Resolution:
    """
  Attributes:
   - Width
   - Height
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.I32,
            'Width',
            None,
            None,
        ),  # 1
        (
            2,
            TType.I32,
            'Height',
            None,
            None,
        ),  # 2
    )

    def __init__(
        self,
        Width=None,
        Height=None,
    ):
        self.Width = Width
        self.Height = Height

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(
                iprot.trans, TTransport.CReadableTransport
        ) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans,
                                     (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.Width = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.Height = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(
                fastbinary.encode_binary(self,
                                         (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('Resolution')
        if self.Width is not None:
            oprot.writeFieldBegin('Width', TType.I32, 1)
            oprot.writeI32(self.Width)
            oprot.writeFieldEnd()
        if self.Height is not None:
            oprot.writeFieldBegin('Height', TType.I32, 2)
            oprot.writeI32(self.Height)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.Width)
        value = (value * 31) ^ hash(self.Height)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value) for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other,
                          self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ImagePayload:
    """
  Attributes:
   - TOSURL
   - MimeType
   - ContentURL
   - ThumbnailURL
   - Resolution
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRING,
            'TOSURL',
            None,
            None,
        ),  # 1
        (
            2,
            TType.STRING,
            'MimeType',
            None,
            None,
        ),  # 2
        (
            3,
            TType.STRING,
            'ContentURL',
            None,
            None,
        ),  # 3
        (
            4,
            TType.STRING,
            'ThumbnailURL',
            None,
            None,
        ),  # 4
        (
            5,
            TType.STRUCT,
            'Resolution',
            (Resolution, Resolution.thrift_spec),
            None,
        ),  # 5
    )

    def __init__(
        self,
        TOSURL=None,
        MimeType=None,
        ContentURL=None,
        ThumbnailURL=None,
        Resolution=None,
    ):
        self.TOSURL = TOSURL
        self.MimeType = MimeType
        self.ContentURL = ContentURL
        self.ThumbnailURL = ThumbnailURL
        self.Resolution = Resolution

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(
                iprot.trans, TTransport.CReadableTransport
        ) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans,
                                     (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.TOSURL = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.MimeType = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.ContentURL = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.ThumbnailURL = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.Resolution = Resolution()
                    self.Resolution.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(
                fastbinary.encode_binary(self,
                                         (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('ImagePayload')
        if self.TOSURL is not None:
            oprot.writeFieldBegin('TOSURL', TType.STRING, 1)
            oprot.writeString(self.TOSURL)
            oprot.writeFieldEnd()
        if self.MimeType is not None:
            oprot.writeFieldBegin('MimeType', TType.STRING, 2)
            oprot.writeString(self.MimeType)
            oprot.writeFieldEnd()
        if self.ContentURL is not None:
            oprot.writeFieldBegin('ContentURL', TType.STRING, 3)
            oprot.writeString(self.ContentURL)
            oprot.writeFieldEnd()
        if self.ThumbnailURL is not None:
            oprot.writeFieldBegin('ThumbnailURL', TType.STRING, 4)
            oprot.writeString(self.ThumbnailURL)
            oprot.writeFieldEnd()
        if self.Resolution is not None:
            oprot.writeFieldBegin('Resolution', TType.STRUCT, 5)
            self.Resolution.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.TOSURL is None:
            raise TProtocol.TProtocolException(
                message='Required field TOSURL is unset!')
        if self.MimeType is None:
            raise TProtocol.TProtocolException(
                message='Required field MimeType is unset!')
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.TOSURL)
        value = (value * 31) ^ hash(self.MimeType)
        value = (value * 31) ^ hash(self.ContentURL)
        value = (value * 31) ^ hash(self.ThumbnailURL)
        value = (value * 31) ^ hash(self.Resolution)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value) for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other,
                          self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VideoPayload:
    """
  Attributes:
   - TOSURL
   - MimeType
   - ContentURL
   - ThumbnailURL
   - duration
   - Resolution
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRING,
            'TOSURL',
            None,
            None,
        ),  # 1
        (
            2,
            TType.STRING,
            'MimeType',
            None,
            None,
        ),  # 2
        (
            3,
            TType.STRING,
            'ContentURL',
            None,
            None,
        ),  # 3
        (
            4,
            TType.STRING,
            'ThumbnailURL',
            None,
            None,
        ),  # 4
        (
            5,
            TType.DOUBLE,
            'duration',
            None,
            None,
        ),  # 5
        (
            6,
            TType.STRUCT,
            'Resolution',
            (Resolution, Resolution.thrift_spec),
            None,
        ),  # 6
    )

    def __init__(
        self,
        TOSURL=None,
        MimeType=None,
        ContentURL=None,
        ThumbnailURL=None,
        duration=None,
        Resolution=None,
    ):
        self.TOSURL = TOSURL
        self.MimeType = MimeType
        self.ContentURL = ContentURL
        self.ThumbnailURL = ThumbnailURL
        self.duration = duration
        self.Resolution = Resolution

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(
                iprot.trans, TTransport.CReadableTransport
        ) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans,
                                     (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.TOSURL = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.MimeType = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.ContentURL = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.ThumbnailURL = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.duration = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.Resolution = Resolution()
                    self.Resolution.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(
                fastbinary.encode_binary(self,
                                         (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('VideoPayload')
        if self.TOSURL is not None:
            oprot.writeFieldBegin('TOSURL', TType.STRING, 1)
            oprot.writeString(self.TOSURL)
            oprot.writeFieldEnd()
        if self.MimeType is not None:
            oprot.writeFieldBegin('MimeType', TType.STRING, 2)
            oprot.writeString(self.MimeType)
            oprot.writeFieldEnd()
        if self.ContentURL is not None:
            oprot.writeFieldBegin('ContentURL', TType.STRING, 3)
            oprot.writeString(self.ContentURL)
            oprot.writeFieldEnd()
        if self.ThumbnailURL is not None:
            oprot.writeFieldBegin('ThumbnailURL', TType.STRING, 4)
            oprot.writeString(self.ThumbnailURL)
            oprot.writeFieldEnd()
        if self.duration is not None:
            oprot.writeFieldBegin('duration', TType.DOUBLE, 5)
            oprot.writeDouble(self.duration)
            oprot.writeFieldEnd()
        if self.Resolution is not None:
            oprot.writeFieldBegin('Resolution', TType.STRUCT, 6)
            self.Resolution.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.TOSURL is None:
            raise TProtocol.TProtocolException(
                message='Required field TOSURL is unset!')
        if self.MimeType is None:
            raise TProtocol.TProtocolException(
                message='Required field MimeType is unset!')
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.TOSURL)
        value = (value * 31) ^ hash(self.MimeType)
        value = (value * 31) ^ hash(self.ContentURL)
        value = (value * 31) ^ hash(self.ThumbnailURL)
        value = (value * 31) ^ hash(self.duration)
        value = (value * 31) ^ hash(self.Resolution)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value) for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other,
                          self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TextPayload:
    """
  Attributes:
   - TOSURL
   - TrucatedContent
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRING,
            'TOSURL',
            None,
            None,
        ),  # 1
        (
            2,
            TType.STRING,
            'TrucatedContent',
            None,
            None,
        ),  # 2
    )

    def __init__(
        self,
        TOSURL=None,
        TrucatedContent=None,
    ):
        self.TOSURL = TOSURL
        self.TrucatedContent = TrucatedContent

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(
                iprot.trans, TTransport.CReadableTransport
        ) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans,
                                     (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.TOSURL = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.TrucatedContent = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(
                fastbinary.encode_binary(self,
                                         (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TextPayload')
        if self.TOSURL is not None:
            oprot.writeFieldBegin('TOSURL', TType.STRING, 1)
            oprot.writeString(self.TOSURL)
            oprot.writeFieldEnd()
        if self.TrucatedContent is not None:
            oprot.writeFieldBegin('TrucatedContent', TType.STRING, 2)
            oprot.writeString(self.TrucatedContent)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.TOSURL is None:
            raise TProtocol.TProtocolException(
                message='Required field TOSURL is unset!')
        if self.TrucatedContent is None:
            raise TProtocol.TProtocolException(
                message='Required field TrucatedContent is unset!')
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.TOSURL)
        value = (value * 31) ^ hash(self.TrucatedContent)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value) for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other,
                          self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Payload:
    """
  Attributes:
   - Image
   - Video
   - Text
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            'Image',
            (ImagePayload, ImagePayload.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            'Video',
            (VideoPayload, VideoPayload.thrift_spec),
            None,
        ),  # 2
        (
            3,
            TType.STRUCT,
            'Text',
            (TextPayload, TextPayload.thrift_spec),
            None,
        ),  # 3
    )

    def __init__(
        self,
        Image=None,
        Video=None,
        Text=None,
    ):
        self.Image = Image
        self.Video = Video
        self.Text = Text

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(
                iprot.trans, TTransport.CReadableTransport
        ) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans,
                                     (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.Image = ImagePayload()
                    self.Image.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.Video = VideoPayload()
                    self.Video.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.Text = TextPayload()
                    self.Text.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(
                fastbinary.encode_binary(self,
                                         (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('Payload')
        if self.Image is not None:
            oprot.writeFieldBegin('Image', TType.STRUCT, 1)
            self.Image.write(oprot)
            oprot.writeFieldEnd()
        if self.Video is not None:
            oprot.writeFieldBegin('Video', TType.STRUCT, 2)
            self.Video.write(oprot)
            oprot.writeFieldEnd()
        if self.Text is not None:
            oprot.writeFieldBegin('Text', TType.STRUCT, 3)
            self.Text.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.Image)
        value = (value * 31) ^ hash(self.Video)
        value = (value * 31) ^ hash(self.Text)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value) for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other,
                          self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FileLine:
    """
  Attributes:
   - Data
   - Annotation
   - Payload
  """

    thrift_spec = (
        None,  # 0
        (
            1,
            TType.STRUCT,
            'Data',
            (Data, Data.thrift_spec),
            None,
        ),  # 1
        (
            2,
            TType.STRUCT,
            'Annotation',
            (Annotation, Annotation.thrift_spec),
            None,
        ),  # 2
        (
            3,
            TType.STRUCT,
            'Payload',
            (Payload, Payload.thrift_spec),
            None,
        ),  # 3
    )

    def __init__(
        self,
        Data=None,
        Annotation=None,
        Payload=None,
    ):
        self.Data = Data
        self.Annotation = Annotation
        self.Payload = Payload

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(
                iprot.trans, TTransport.CReadableTransport
        ) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans,
                                     (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.Data = Data()
                    self.Data.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.Annotation = Annotation()
                    self.Annotation.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.Payload = Payload()
                    self.Payload.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(
                fastbinary.encode_binary(self,
                                         (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('FileLine')
        if self.Data is not None:
            oprot.writeFieldBegin('Data', TType.STRUCT, 1)
            self.Data.write(oprot)
            oprot.writeFieldEnd()
        if self.Annotation is not None:
            oprot.writeFieldBegin('Annotation', TType.STRUCT, 2)
            self.Annotation.write(oprot)
            oprot.writeFieldEnd()
        if self.Payload is not None:
            oprot.writeFieldBegin('Payload', TType.STRUCT, 3)
            self.Payload.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.Data is None:
            raise TProtocol.TProtocolException(
                message='Required field Data is unset!')
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.Data)
        value = (value * 31) ^ hash(self.Annotation)
        value = (value * 31) ^ hash(self.Payload)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value) for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other,
                          self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
